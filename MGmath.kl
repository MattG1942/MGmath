// MG Math (c) Matt Graves 2014
// This provides some additions to the basic mathmatical functions.

// Array Arithmatic Operators
// +, -, *, / or % a single value with an array to return an array of the same size as the origional array.
// Each value in the array is concidered individually when applying the operation.
// eg. [1,2,3] + 5 = [6,7,8] or 12 / [4,3,2] = [3,4,6]
// types suported: (x is suported)
// UInt8
// SInt8
// UInt16
// SInt16
// UInt32
// SInt32
// UInt64
// SInt64
// Float32 x
// Float64
// (Goal all numerical)

// a[] + b
operator multiPlus<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = a[index] + b;
}
function Float32[] +(Float32 a[], Float32 b) {
  Float32 c[];
  c.resize(a.size);
  // for (Integer i = 0; i < a.size; i++) {
  //   c[i] = a[i] + b;
  // }
  multiPlus<<<a.size>>>(a,b,c);
  return c;
}
function Float32[] +(Float32 b, Float32 a[]) {
  Float32 c[];
  c.resize(a.size);
  multiPlus<<<a.size>>>(a,b,c);
  return c;
}

// a[] - b
operator multiAMinusB<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = a[index] - b;
}
function Float32[] -(Float32 a[], Float32 b) {
  Float32 c[];
  c.resize(a.size);
  multiAMinusB<<<a.size>>>(a,b,c);
  return c;
}
// b - a[]
operator multiBMinusA<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = b - a[index];
}
function Float32[] -(Float32 b, Float32 a[]) {
  Float32 c[];
  c.resize(a.size);
  multiBMinusA<<<a.size>>>(a,b,c);
  return c;
}

// a[] * b
operator multiMultiply<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = a[index] * b;
}
function Float32[] *(Float32 a[], Float32 b) {
  Float32 c[];
  c.resize(a.size);
  multiMultiply<<<a.size>>>(a,b,c);
  return c;
}
function Float32[] *(Float32 b, Float32 a[]) {
  Float32 c[];
  c.resize(a.size);
  multiMultiply<<<a.size>>>(a,b,c);
  return c;
}

// a[] / b
operator multiADivideB<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = a[index] / b;
}
function Float32[] /(Float32 a[], Float32 b) {
  Float32 c[];
  c.resize(a.size);
  multiADivideB<<<a.size>>>(a,b,c);
  return c;
}
// b / a[]
operator multiBDivideA<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = b / a[index];
}
function Float32[] /(Float32 b, Float32 a[]) {
  Float32 c[];
  c.resize(a.size);
  multiBDivideA<<<a.size>>>(a,b,c);
  return c;
}

// a[] % b
operator multiAModB<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = a[index] % b;
}
function Float32[] %(Float32 a[], Float32 b) {
  Float32 c[];
  c.resize(a.size);
  multiAModB<<<a.size>>>(a,b,c);
  return c;
}
// b % a[]
operator multiBModA<<<index>>>(Float32 a[], Float32 b, io Float32 c[]) {
  c[index] = b % a[index];
}
function Float32[] %(Float32 b, Float32 a[]) {
  Float32 c[];
  c.resize(a.size);
  multiBModA<<<a.size>>>(a,b,c);
  return c;
}